#!/usr/bin/env python
try:
    from ConfigParser import RawConfigParser  # python2
except ImportError:
    # pip install future
    from configparser import RawConfigParser  # python3
import re
from assert_exists import assert_exists
from objectname import objectname
from fullpath import fullpath
from public import public
from tolist import tolist


@public
class SectionProxy(object):
    _conf = None
    _section = None

    def __init__(self, conf, section):
        self._conf = conf
        self._section = section

    @property
    def conf(self):  # read only
        return self._conf

    @property
    def _group(self):
        return re.sub("\"(.*)\"", "", self._section).rstrip()

    @property
    def _name(self):
        matches = re.findall("\"(.*)\"", self._section)
        if matches:
            return matches[0]

    @property
    def name(self):
        name = self.get("name")
        if name:
            return name
        return self._name

    @name.setter
    def name(self, name):
        self.set("name", name)

    def _options(self):
        return self.conf.options(self._section)

    def get(self, key, default=None):
        """get key value"""
        return self.conf.get(self._section, key, default)

    def set(self, key, value):
        """set key value"""
        return self.conf.set(self._section, key, value)

    def delete(self):
        """delete section"""
        self.conf.unset(self._section)

    def keys(self):
        """return section keys"""
        return self.conf.options(self._section)

    @property
    def __dict__(self):
        """return dict with section items"""
        result = dict()
        for k in self.keys():
            result.update({k: self[k]})
        return result

    def __contains__(self, key):
        return key in self.keys()

    def __getattribute__(self, key):
        if hasattr(type(self), key):
            return object.__getattribute__(self, key)
        return self.conf.get(self._section, key)

    def __getitem__(self, key):
        return self.conf.get(self._section, key)

    def __iter__(self):
        return self._options().__iter__()

    def __len__(self):
        return len(self._options())

    def __setattr__(self, k, v):
        if hasattr(type(self), k):
            return object.__setattr__(self, k, v)
        self.conf.set(self._section, k, v)

    def __repr__(self):
        return '<Section: {0}>'.format(self._section)


@public
class Conf(object):
    path = None
    _parser = None
    autosave = True

    def __init__(self, path, parser=None, autosave=True):
        self.path = fullpath(path)
        self.autosave = autosave
        if not parser:
            parser = RawConfigParser()
            path = fullpath(path)
            assert_exists(path)
            parser.read(path)
        self._parser = parser

    @property
    def parser(self):  # read only
        return self._parser

    def get(self, section, k, default=None):
        try:
            return self.parser.get(section, k)
        except:  # NoOptionError, NoSectionError
            return default

    def set(self, section, key, value):
        try:
            self.parser.add_section(section)
        except:
            pass
        self.parser.set(section, key, value)
        self.write()

    def items(self, section):
        return self.parser.items(section)

    def remove_option(self, section, option):
        for option in tolist(option):
            if self.has_option(section, option):
                self.parser.remove_option(section, option)
        self.save()

    def remove_section(self, section):
        for i in tolist(section):
            object = self[i]
            if object:
                id = object._section
                self.parser.remove_section(id)
        self.save()

    def save(self):
        if self.autosave:
            self.write()

    def write(self):
        path = str(self.fullpath)
        self.parser.write(open(path, "w"))

    def add_section(self, section):
        for section in tolist(section):
            if section not in self:
                self.parser.add_section(section)
        self.save()

    def has_section(self, section):
        return self.parser.has_section(section)

    def has_option(self, section, option):
        return self.parser.has_option(section, option)

    def options(self, section):
        return self.parser.options(section)

    @property
    def sections(self):
        """return list with config sections"""
        return list(self.parser.sections())

    def __contains__(self, section):
        return self[section] is not None

    def __delitem__(self, key):
        if not key:
            return
        if hasattr(key, "_name"):  # SectionProxy object
            key = key._name
        self.remove_section(key)

    def __getattribute__(self, key):
        if hasattr(type(self), key):
            return object.__getattribute__(self, key)
        if key in self:
            return self[key]

    def __getitem__(self, key):
        if hasattr(key, "_name"):  # SectionProxy object
            key = key._name
        if key in self.sections:
            return SectionProxy(self, key)

    def __iter__(self):
        for section in self.sections:
            yield self[section]

    def __str__(self):
        return "<%s object '%s'>" % (objectname(
            self.__class__, fullname=True), self.path)
